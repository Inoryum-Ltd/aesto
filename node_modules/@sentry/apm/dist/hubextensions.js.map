{"version":3,"file":"hubextensions.js","sourceRoot":"","sources":["../src/hubextensions.ts"],"names":[],"mappings":";AAAA,mCAAkD;AAGlD,+BAA8B;AAE9B,qEAAqE;AACrE,SAAS,YAAY;IACnB,aAAa;IACb,IAAM,IAAI,GAAG,IAAW,CAAC;IACzB,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;IAC9B,IAAI,KAAK,EAAE;QACT,IAAM,IAAI,GAAG,KAAK,CAAC,OAAO,EAAE,CAAC;QAC7B,IAAI,IAAI,EAAE;YACR,OAAO;gBACL,cAAc,EAAE,IAAI,CAAC,aAAa,EAAE;aACrC,CAAC;SACH;KACF;IACD,OAAO,EAAE,CAAC;AACZ,CAAC;AAED;;;;;;GAMG;AACH,SAAS,SAAS,CAAC,WAAyB;IAC1C,aAAa;IACb,IAAM,GAAG,GAAG,IAAW,CAAC;IACxB,IAAM,KAAK,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC;IAC7B,IAAM,MAAM,GAAG,GAAG,CAAC,SAAS,EAAE,CAAC;IAC/B,IAAI,IAAI,CAAC;IAET,6GAA6G;IAC7G,+GAA+G;IAC/G,IAAI,YAAY,GAAG,KAAK,CAAC;IAEzB,IAAI,KAAK,EAAE;QACT,IAAM,UAAU,GAAG,KAAK,CAAC,OAAO,EAAU,CAAC;QAC3C,IAAI,UAAU,EAAE;YACd,IAAI,GAAG,UAAU,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YACrC,YAAY,GAAG,IAAI,CAAC;SACrB;KACF;IAED,IAAI,CAAC,IAAI,EAAE;QACT,IAAI,GAAG,IAAI,WAAI,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC;KACnC;IAED,0GAA0G;IAC1G,IAAI,IAAI,CAAC,OAAO,KAAK,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;QACnD,IAAM,UAAU,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QACzE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,UAAU,CAAC;KAC3C;IAED,mEAAmE;IACnE,gHAAgH;IAChH,IAAI,IAAI,CAAC,OAAO,IAAI,CAAC,YAAY,EAAE;QACjC,IAAM,kBAAkB,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;QAC9E,IAAI,CAAC,gBAAgB,CAAC,kBAAkB,CAAC,QAAkB,CAAC,CAAC;KAC9D;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;GAEG;AACH,SAAgB,mBAAmB;IACjC,IAAM,OAAO,GAAG,oBAAc,EAAE,CAAC;IACjC,IAAI,OAAO,CAAC,UAAU,EAAE;QACtB,OAAO,CAAC,UAAU,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,UAAU,IAAI,EAAE,CAAC;QACpE,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,SAAS,EAAE;YAC5C,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,SAAS,GAAG,SAAS,CAAC;SACrD;QACD,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,YAAY,EAAE;YAC/C,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,YAAY,GAAG,YAAY,CAAC;SAC3D;KACF;AACH,CAAC;AAXD,kDAWC","sourcesContent":["import { getMainCarrier, Hub } from '@sentry/hub';\nimport { SpanContext } from '@sentry/types';\n\nimport { Span } from './span';\n\n/** Returns all trace headers that are currently on the top scope. */\nfunction traceHeaders(): { [key: string]: string } {\n  // @ts-ignore\n  const that = this as Hub;\n  const scope = that.getScope();\n  if (scope) {\n    const span = scope.getSpan();\n    if (span) {\n      return {\n        'sentry-trace': span.toTraceparent(),\n      };\n    }\n  }\n  return {};\n}\n\n/**\n * This functions starts a span. If argument passed is of type `Span`, it'll run sampling on it if configured\n * and attach a `SpanRecorder`. If it's of type `SpanContext` and there is already a `Span` on the Scope,\n * the created Span will have a reference to it and become it's child. Otherwise it'll crete a new `Span`.\n *\n * @param spanContext Already constructed span or properties with which the span should be created\n */\nfunction startSpan(spanContext?: SpanContext): Span {\n  // @ts-ignore\n  const hub = this as Hub;\n  const scope = hub.getScope();\n  const client = hub.getClient();\n  let span;\n\n  // This flag determines if we already added the span as a child to the span that currently lives on the scope\n  // If we do not have this, we will add it later on twice to the span recorder and therefore have too many spans\n  let addedAsChild = false;\n\n  if (scope) {\n    const parentSpan = scope.getSpan() as Span;\n    if (parentSpan) {\n      span = parentSpan.child(spanContext);\n      addedAsChild = true;\n    }\n  }\n\n  if (!span) {\n    span = new Span(spanContext, hub);\n  }\n\n  // We only roll the dice on sampling for \"root\" spans (transactions) because the childs inherit this state\n  if (span.sampled === undefined && span.isRootSpan()) {\n    const sampleRate = (client && client.getOptions().tracesSampleRate) || 0;\n    span.sampled = Math.random() < sampleRate;\n  }\n\n  // We only want to create a span list if we sampled the transaction\n  // in case we will discard the span anyway because sampled == false, we safe memory and do not store child spans\n  if (span.sampled && !addedAsChild) {\n    const experimentsOptions = (client && client.getOptions()._experiments) || {};\n    span.initSpanRecorder(experimentsOptions.maxSpans as number);\n  }\n\n  return span;\n}\n\n/**\n * This patches the global object and injects the APM extensions methods\n */\nexport function addExtensionMethods(): void {\n  const carrier = getMainCarrier();\n  if (carrier.__SENTRY__) {\n    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n    if (!carrier.__SENTRY__.extensions.startSpan) {\n      carrier.__SENTRY__.extensions.startSpan = startSpan;\n    }\n    if (!carrier.__SENTRY__.extensions.traceHeaders) {\n      carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;\n    }\n  }\n}\n"]}