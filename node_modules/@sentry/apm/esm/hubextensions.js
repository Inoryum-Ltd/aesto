import { getMainCarrier } from '@sentry/hub';
import { Span } from './span';
/** Returns all trace headers that are currently on the top scope. */
function traceHeaders() {
    // @ts-ignore
    var that = this;
    var scope = that.getScope();
    if (scope) {
        var span = scope.getSpan();
        if (span) {
            return {
                'sentry-trace': span.toTraceparent(),
            };
        }
    }
    return {};
}
/**
 * This functions starts a span. If argument passed is of type `Span`, it'll run sampling on it if configured
 * and attach a `SpanRecorder`. If it's of type `SpanContext` and there is already a `Span` on the Scope,
 * the created Span will have a reference to it and become it's child. Otherwise it'll crete a new `Span`.
 *
 * @param spanContext Already constructed span or properties with which the span should be created
 */
function startSpan(spanContext) {
    // @ts-ignore
    var hub = this;
    var scope = hub.getScope();
    var client = hub.getClient();
    var span;
    // This flag determines if we already added the span as a child to the span that currently lives on the scope
    // If we do not have this, we will add it later on twice to the span recorder and therefore have too many spans
    var addedAsChild = false;
    if (scope) {
        var parentSpan = scope.getSpan();
        if (parentSpan) {
            span = parentSpan.child(spanContext);
            addedAsChild = true;
        }
    }
    if (!span) {
        span = new Span(spanContext, hub);
    }
    // We only roll the dice on sampling for "root" spans (transactions) because the childs inherit this state
    if (span.sampled === undefined && span.isRootSpan()) {
        var sampleRate = (client && client.getOptions().tracesSampleRate) || 0;
        span.sampled = Math.random() < sampleRate;
    }
    // We only want to create a span list if we sampled the transaction
    // in case we will discard the span anyway because sampled == false, we safe memory and do not store child spans
    if (span.sampled && !addedAsChild) {
        var experimentsOptions = (client && client.getOptions()._experiments) || {};
        span.initSpanRecorder(experimentsOptions.maxSpans);
    }
    return span;
}
/**
 * This patches the global object and injects the APM extensions methods
 */
export function addExtensionMethods() {
    var carrier = getMainCarrier();
    if (carrier.__SENTRY__) {
        carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
        if (!carrier.__SENTRY__.extensions.startSpan) {
            carrier.__SENTRY__.extensions.startSpan = startSpan;
        }
        if (!carrier.__SENTRY__.extensions.traceHeaders) {
            carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
        }
    }
}
//# sourceMappingURL=hubextensions.js.map