import { Hub } from '@sentry/hub';
import { Span as SpanInterface, SpanContext, SpanStatus } from '@sentry/types';
export declare const TRACEPARENT_REGEXP: RegExp;
/**
 * Keeps track of finished spans for a given transaction
 */
declare class SpanRecorder {
    private readonly _maxlen;
    spans: Span[];
    constructor(maxlen?: number);
    /**
     * This is just so that we don't run out of memory while recording a lot
     * of spans. At some point we just stop and flush out the start of the
     * trace tree (i.e.the first n spans with the smallest
     * start_timestamp).
     */
    add(span: Span): void;
}
/**
 * Span contains all data about a span
 */
export declare class Span implements SpanInterface, SpanContext {
    /**
     * The reference to the current hub.
     */
    private readonly _hub;
    /**
     * @inheritDoc
     */
    private readonly _traceId;
    /**
     * @inheritDoc
     */
    private readonly _spanId;
    /**
     * @inheritDoc
     */
    private readonly _parentSpanId?;
    /**
     * Internal keeper of the status
     */
    private _status?;
    /**
     * @inheritDoc
     */
    sampled?: boolean;
    /**
     * Timestamp in seconds when the span was created.
     */
    startTimestamp: number;
    /**
     * Timestamp in seconds when the span ended.
     */
    timestamp?: number;
    /**
     * @inheritDoc
     */
    transaction?: string;
    /**
     * @inheritDoc
     */
    op?: string;
    /**
     * @inheritDoc
     */
    description?: string;
    /**
     * @inheritDoc
     */
    tags: {
        [key: string]: string;
    };
    /**
     * @inheritDoc
     */
    data: {
        [key: string]: any;
    };
    /**
     * List of spans that were finalized
     */
    spanRecorder?: SpanRecorder;
    /**
     * You should never call the custructor manually, always use `hub.startSpan()`.
     * @internal
     * @hideconstructor
     * @hidden
     */
    constructor(spanContext?: SpanContext, hub?: Hub);
    /**
     * Attaches SpanRecorder to the span itself
     * @param maxlen maximum number of spans that can be recorded
     */
    initSpanRecorder(maxlen?: number): void;
    /**
     * @inheritDoc
     */
    child(spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>): Span;
    /**
     * @inheritDoc
     */
    isRootSpan(): boolean;
    /**
     * Continues a trace from a string (usually the header).
     * @param traceparent Traceparent string
     */
    static fromTraceparent(traceparent: string, spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>): Span | undefined;
    /**
     * @inheritDoc
     */
    setTag(key: string, value: string): this;
    /**
     * @inheritDoc
     */
    setData(key: string, value: any): this;
    /**
     * @inheritDoc
     */
    setStatus(value: SpanStatus): this;
    /**
     * @inheritDoc
     */
    setHttpStatus(httpStatus: number): this;
    /**
     * @inheritDoc
     */
    isSuccess(): boolean;
    /**
     * Sets the finish timestamp on the current span.
     * @param trimEnd If true, sets the end timestamp of the transaction to the highest timestamp of child spans, trimming
     * the duration of the transaction span. This is useful to discard extra time in the transaction span that is not
     * accounted for in child spans, like what happens in the idle transaction Tracing integration, where we finish the
     * transaction after a given "idle time" and we don't want this "idle time" to be part of the transaction.
     */
    finish(trimEnd?: boolean): string | undefined;
    /**
     * @inheritDoc
     */
    toTraceparent(): string;
    /**
     * @inheritDoc
     */
    getTraceContext(): {
        data?: {
            [key: string]: any;
        };
        description?: string;
        op?: string;
        parent_span_id?: string;
        span_id: string;
        status?: string;
        tags?: {
            [key: string]: string;
        };
        trace_id: string;
    };
    /**
     * @inheritDoc
     */
    toJSON(): {
        data?: {
            [key: string]: any;
        };
        description?: string;
        op?: string;
        parent_span_id?: string;
        sampled?: boolean;
        span_id: string;
        start_timestamp: number;
        tags?: {
            [key: string]: string;
        };
        timestamp?: number;
        trace_id: string;
        transaction?: string;
    };
}
export {};
//# sourceMappingURL=span.d.ts.map